--------

## 5.1 수식과 연산자

> [!NOTE]
> 수식은 변수, 상수, 연산자들의 조합입니다.
>
> 가장 간단한 수식은 변수 또는 상수 하나만 있는 것으로 상수 10도 수식입니다.
>
> `y = 10 + 20 ;` 에서 `y`, `10`, `20`이 피연산자이고, `=`, `+`이 연산자입니다.
> `;`은 문장의 끝을 나타내는 구분 기호입니다.
>
> 연산자를 단항 연산자, 이항 연산자, 삼항 연산자로 나누는 기준은 피연산자 몇개에 연산이 적용되는지 입니다.
>
> 단항 연산자: 증감 연산자 `++a`, `--a`, `a++`, `a--`, 부호 연산자 `+a`, `-a`,
> 비트 NOT 연산자 `~a`, 논리 NOT 연산자 `!a`, 간접 참조 연산자 `*a`, 주소 추출 연산자 `&a`,
> 형변환 연산자 `(자료형)a`, 크기 계산 연산자 `sizeof a`, `sizeof (자료형)`,
> 정렬 요구 연산자 `_Alignof (자료형)`
>
> 이항 연산자: 대입 연산자 `a = b`,
> 복합 대입 연산자 `a += b`, `a -= b`, `a *= b`, `a /= b`, `a %= b`, `a &= b`, `a |= b`,
> `a ^= b`, `a <<= b`, `a >>= b`, 덧셈 연산자 `a + b`, 뺄셈 연산자 `a - b`, 곱셈 연산자 `a * b`,
> 나눗셈 연산자 `a / b`, 나머지 연산자 `a % b`, 비트 AND 연산자 `a & b`, 비트 OR 연산자 `a | b`,
> 비트 XOR 연산자 `a ^ b`, 비트 이동 연산자 `a << b`, `a >> b`,
> 관계 연산자 `a == b`, `a != b`, `a < b`, `a > b`, `a <= b`, `a >= b`,
> 배열 인덱스 연산자 `a[b]`, 구조체 포인터 접근 연산자 `a->b`, 구조체 멤버 접근 연산자 `a.b`,
> 콤마 연산자 `a, b`
>
> 삼항 연산자: 삼항 조건 연산자 `a ? b : c`
>
> 기타 연산자: 함수 호출 연산자 `a(...)`, 복합 리터럴 연산자 `(자료형){리스트}`

</br>

## 5.2 산술 연산자

> [!NOTE]
> 증감 연산자 `x++`를 풀어쓰면 `x = x + 1, x - 1`과 같습니다.
>
> `x++`와 `++x`의 차이점은 연산 결과 값입니다. `x++`의 결과 값은 `x`에 1을 더하기 전 값입니다.
> `++x`의 결과 값은 `x`에 1을 더한 후 값입니다. 
>
> ```c
> int x = 10;
> printf("%d\n", (1 + x++) + 2);
> ```
> 를 실행하면, 먼저 첫번째 줄 `int x = 10;`이 실행됩니다.
> int를 저장할 수 있는 새 메모리 공간이 할당되고, 메모리 공간에 x라는 이름이 붙고, 10이라는 값이 저장됩니다.
>
> 이어서 두번째 줄 `printf("%d\n", (1 + x++) + 2);`가 실행됩니다.
> printf가 가리키는 함수는 `#include <stdio.h>`를 앞에서 했으면 표준 라이브러리의 출력 함수입니다.
> 함수 이름 `printf`가 어떤 함수를 가리키는지, 첫번째 인자와 두번째 인자에 들어갈 값이 무엇인지 정해집니다.
> 첫번째 인수 위치의 수식 `"%d\n"`의 값은 문자열 리터럴 `"%d\n"` 입니다.
> 두번째 인수 위치의 수식 `(1 + x++) + 2`의 값은 `(1 + x++)`와 `2`를 더한 값입니다.
> `(1 + x++)` 값은 `1`과 `x++`를 더한 값입니다.
> `1`의 값은 int 리터럴 `1`이고, `x++`의 값은 `x`에 저장되어 있는 값인 10이므로, 
> `(1 + x++)` 의 값은 11입니다.
> 두번째 인수 위치의 수식 `(1 + x++) + 2`의 값은 13이 됩니다.
> `printf("%d\n", (1 + x++) + 2);`는 표준 라이브러리의 출력 함수를 호출하며,
> 첫번째 인자인 형식 문자열 `"%d\n"`에 따라 두번째 인자의 값을 정수 형태로 출력하고 (`%d`), 줄바꿈을 합니다 (`\n`).

</br>

## 5.3 대입 연산자

> [!NOTE]
> 대입 연산자에서 lvalue가 될 수 있는 것은 변수입니다.
> 
> 대입 연산자 `=`는 수학에서와 다르게 왼쪽 피연산자에 해당하는 메모리 공간에 오른쪽 피연산자의 값을 저장합니다.
>
> `x *= y`는 `x`가 가리키는 메모리 주소가 한번만 계산된다는 것만 제외하면 `x = x * y`와 동일합니다.
>
> `10 % 6`이 계산되는 과정은 먼저 연산자 `%`의 피연산자에 해당하는 `10`과 `6`의 값이 `int` 리터럴 10과 6으로 계산됩니다.
> 그리고 10과 6의 나머지 연산을 한 4가 계산됩니다.
>
> 정수를 나누기 연산을 한 결과는 정수인 몫으로 나옵니다. 10을 6으로 나누면 1이 나옵니다.
>
> `x+=y`를 C 프로그래밍 언어의 문법으로 쓰면 이항연산자 `+=`의 피연산자가 `x`와 `y`로 있는 것입니다.
> `x=+y`를 C 프로그래밍 언어의 문법으로 쓰면 이항연산자 `=`과 단항연산자 `+`가 있고,
> 연산자 우선순위에 따라서 단항연산자 `+`가 먼저 계산됩니다.
> 따라서 이항연산자 `=`의 피연산자는 `x`와 `+y`가 되고, 단항연산자 `+`의 피연산자는 `y`가 됩니다. 

</br>


## 5.4 관계 연산자

> [!NOTE]
> 관계 수식의 결과로 생성될 수 있는 값은 0과 1 입니다.
>
> `(3 >= 2) + 5`의 값은 `(1) + 5`의 값과 같아서 6이 됩니다.
>
> 부동소수점수를 나타낼 때 오차가 있으므로 이를 인지하고 비교해야 합니다. `x == y`를 의도했으면,
> `x - y < 작은양수 && x - y > 작은음수`로 비교합니다.  

</br>



## 5.5 논리 연산자

> [!NOTE]
> 무주택 기간 3년 이상, 가구주 연령 40세 이상, 가족 수 3명 이상에 해당하는 논리 연산식은
> `무주택_기간 >= 3 && 가구주_연령 >= 40 && 가족_수 >= 3` 입니다.
>
> 상수 `10`은 0이 아니므로 참입니다.
>
> 수식 `!3`의 값은 참의 NOT 연산 결과로 거짓인 0 입니다.
>
> 단축 계산의 예는 다음과 같습니다.
> ```c
> #include <stdio.h>
>
> int main(void) {
>   int x = 0;
>   int ans = 1 || (x = 2);
>   printf("ans = %d, x = %d", ans, x);
> }
>
> /* 실행 결과: ans = 1, x = 0 */
> ```
> OR 연산자에서 왼쪽 피연산자 수식의 값이 참이면 오른쪽 피연산자 수식은 계산되지 않습니다. 

</br>

## 5.8 비트 연산자

> [!NOTE]
> `a << b`는 a 값의 모든 비트를 b번 왼쪽으로 이동한 값을 결과로 냅니다.
>
> `~a`는 a 값의 모든 비트에서 0과 1을 바꾼 값을 결과로 냅니다.
>
> 정수 값에서 왼쪽으로 비트를 한칸씩 이동시키면 값이 두배가 됩니다.
>
> 정수 값에서 오른쪽으로 비트를 한칸씩 이동시키면 값이 절반이 됩니다.
> 

</br>


## 5.9 형변환

> [!NOTE]
> 내림 변환은 값의 자료형을 원래보다 범위가 더 작은 자료형으로 바꾸는 것입니다.
> 정수형 값을 다른 정수형으로 내림변환할 때, 값이 변환 대상 자료형의 범위를 넘어서면,
> 변환 대상 자료형이 나타낼 수 있는 최대 개수만큼 값에서 더하거나 빼서 표현 가능한 범위 내로 만든 값을 저장합니다.
> 부동소수점형 값을 자료형 범위 내의 정수형으로 내림변환할 경우 소수점 이하 부분이 모두 0이 되고, 남은 정수값이
> 변환 대상 자료형으로 변환됩니다.
>
> 올림 변환은 값의 자료형을 원래보다 범위가 더 큰 자료형으로 바꾸는 것입니다.
> 
>
> int형 변수 x를 double형으로 형변환하는 수식은 `(double) x` 입니다.
>
> 하나의 수식에 정수와 부동소수점수가 섞여 있으면 수식에 있는 연산자들 중에는 피연산자가 정수와 부동소수점수인 경우가 존재합니다.
> 

</br>


## 5.10 연산자의 우선순위와 결합 규칙

> [!NOTE]
> 연산자 중에서 가장 우선 순위가 낮은 연산자는 콤마 `,` 연산자입니다.
>
> 논리 AND 연산자 `&&`는 논리 OR 연산자 `||` 보다 우선순위가 높습니다.
>
> 단항 연산자 

</br>

